import json
from fastapi import APIRouter, HTTPException, Request
from pathlib import Path
from backend.config.settings import settings

# Chroma/embedding dependencies
from backend.modules.memory.chromadb_adapter import ChromaDBAdapter
from sentence_transformers import SentenceTransformer

router = APIRouter()

# --- REMOVED: Global ChromaDB instantiation causing og path initialization at import time ---
# SOUL_LEARNINGS_PATH = settings.paths.get_learnings_jsonl_path("og")
# COLLECTION_NAME = "roampal_og_soul_fragments"  # Had hardcoded "og"
# chroma_db = ChromaDBAdapter(persistence_directory=settings.paths.get_vector_db_dir(settings.active_shard))  # GLOBAL

# --- MULTI-SHARD COMPATIBLE: No global instantiation ---
EMBEDDING_MODEL = SentenceTransformer("all-MiniLM-L6-v2")

def load_learnings():
    if not SOUL_LEARNINGS_PATH.exists():
        return []
    with open(SOUL_LEARNINGS_PATH, "r", encoding="utf-8") as f:
        return [json.loads(line) for line in f if line.strip()]

def save_learnings(learnings):
    with open(SOUL_LEARNINGS_PATH, "w", encoding="utf-8") as f:
        for l in learnings:
            f.write(json.dumps(l) + "\n")

async def upsert_to_chroma(text, id, meta):
    if not text or len(text) < 5:
        return
    try:
        await chroma_db.initialize(collection_name=COLLECTION_NAME)
        vector = EMBEDDING_MODEL.encode([text]).tolist()
        await chroma_db.upsert_vectors(
            ids=[str(id) or str(hash(text))],
            vectors=vector,
            metadatas=[meta]
        )
    except Exception as e:
        logger.error(f"[Chroma] Upsert failed: {e}")

@router.post("/feedback")
async def memory_feedback(payload: dict):
    """
    Accepts feedback for a learning fragment (reinforce, weaken, correct).
    payload: { "fragment_id": "some_id", "action": "reinforce"|"weaken"|"correct", "text": "optional replacement" }
    """
    fragment_id = payload.get("fragment_id")
    action = payload.get("action")
    new_text = payload.get("text")
    if not fragment_id or not action:
        raise HTTPException(status_code=400, detail="Missing fragment_id or action.")
    
    learnings = load_learnings()
    found = False
    upsert_entry = None
    for entry in learnings:
        if str(entry.get("chunk_id", "")) == fragment_id or str(entry.get("learning_id", "")) == fragment_id:
            found = True
            # Adjust score
            if action == "reinforce":
                entry["score"] = min(float(entry.get("score", 5)) + 1, 10)
            elif action == "weaken":
                entry["score"] = max(float(entry.get("score", 5)) - 1, 0)
            elif action == "correct" and new_text:
                entry["text"] = new_text
                entry["score"] = 5
            else:
                raise HTTPException(status_code=400, detail="Invalid action or missing correction text.")
            upsert_entry = entry
            break
    if not found:
        raise HTTPException(status_code=404, detail="Learning fragment not found.")
    save_learnings(learnings)

    # ---- UPLOAD TO CHROMA EVERY TIME ----
    if upsert_entry:
        text = upsert_entry.get("learning_content") or upsert_entry.get("text")
        id = upsert_entry.get("chunk_id") or upsert_entry.get("learning_id") or hash(text)
        meta = {k: v for k, v in upsert_entry.items() if k not in ("learning_content", "text")}
        await upsert_to_chroma(text, id, meta)

    return {"status": "success", "fragment_id": fragment_id, "action": action}

@router.get("/learnings")
async def get_all_learnings():
    learnings = load_learnings()
    return {"learnings": learnings}
